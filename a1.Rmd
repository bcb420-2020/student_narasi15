---
title: "Assignment 1: Data Set Selection and Initial Processing"
author: "Priyanka Narasimhan"
output: html
---

# This R Notebook will provide insight on the initial preparation and analysis of the dataset GSE136864. 
# Resources: Sample code from lectures 3 & 4, and RPR-GEO2R.R file from Prof. Streipe was used.

# 0 - Install and load additional packages like BiocManager, BioBase, & GEOquery
```{r}
rm(list = ls())
if (! requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}
if (! requireNamespace("Biobase", quietly = TRUE)) {
  BiocManager::install("Biobase")
}
if (! requireNamespace("GEOquery", quietly = TRUE)) {
  BiocManager::install("GEOquery")
}

# Load
library(BiocGenerics)
library(Biobase)
library(GEOquery)
```

# 1 - Download the dataset from GEO
```{r}
gset <- GEOquery::getGEO("GSE136864", GSEMatrix =TRUE)
# Some additional info:
length(gset) # the length is 1
edata <- gset[[1]]
edata # This is our expression matrix
# Our phenodata returns a dataframe that shows our 17 GEO samples, and 49 variable (column) labels
names = (pData(edata))
names
```

# Download Supplementary file(s), there is only 1 
```{r}
supfile <- NULL
sfilename="GSE136864_elf1_counts_matrix.txt.gz" 
# Don't download if supp. file already exists
if (!file.exists(sfilename)) {
    supfile <- getGEOSuppFiles('GSE136864')
 } 
fnames = rownames(supfile)
fnames
```

# 2 - Assessing the Dataset 
Uniprot tells us: ETS-related transcription factor Elf-1 is a protein, gene name is ELF1
Definition 1: A transcription factor is a protein that controls the rate of transcription
Definition 2: A type I interferon (IFN) is a subgroup of proteins that help regulate the activity of the immune system 

This particular dataset studies the transcription factor ELF1, and it's effect in inbihiting replication of viral
infections (like influenza), independent of type I interferons. 
 
# Some general information about this platform:

```{r}
gse <- getGEO("GSE136864", GSEMatrix=FALSE)
current_gpl <- names(GPLList(gse))[1]
current_gpl_info <- Meta(getGEO(current_gpl))
```

**Platform title:** `r current_gpl_info$title`
**Submission date:** `r current_gpl_info$submission_date`
**Last updated date:** `r current_gpl_info$last_update_date`
**Organism:** `r current_gpl_info$organism`
**Number of GEO datasets that use this technology:** `r length(current_gpl_info$series_id)`
**Number of GEO samples that use this technology:** `r length(current_gpl_info$sample_id)`

# Experimental Design:

A549 cells (which are found in lung tissue), were used in the experiment. These cells were either:
- not-transduced 
- or transduced with empty vector, ELF1-WT, or ELF1-R8A mutant. 
In addition, indicated cultures were stimulated with interferon beta for 6 hours or 48 hours. 
All samples were harvested simultaneously and analyzed by RNA-Seq

# Get some data about the supplementary files
```{r}
sfiles = getGEOSuppFiles('GSE136864')
counts = read.delim(rownames(sfiles)[1],header=TRUE, check.names = FALSE)
head(counts)
```

```{r}
dim(counts) # returns [1] 63678    18
```

```{r}
# Use column 1 in the 'counts' table as the rownames
rownames(counts) <- counts[, 1]
counts

# check for any duplicate rownames, there are no duplicate row names!
any(duplicated(rownames(counts)))
```

```{r}
# Define groups, using 1, 3, and 2 token after split string
# "Treatment" column - tells us which was transduced in this test, it could be either empty, ELF1, cell or R8A
# "trial_num" - replicate number
# Test_run is just a concatenation of the 2 columns Treatment and mock_or_IFN to get the name of a sample test run
samples <- data.frame(lapply(colnames(counts)[2:18],
                             FUN = function(x) {
                               unlist(strsplit(x, split="_"))[c(1, 3, 2)]
                             }))
colnames(samples) <- colnames(counts)[2:18]
rownames(samples) <- c("Treatment", "trial_num", "mock_or_IFN")
samples <- data.frame(t(samples))
samples$Test_run = paste(samples$Treatment,"_",samples$mock_or_IFN)
samples
```

# 3 - Map to HUGO symbols
Our dataset curently contains 63,678 Ensembl (ENSG) genes which need to be mapped to HUGO symbols.
```{r}
# install and load the necessary libraries
if (! requireNamespace("org.Hs.eg.db", quietly = TRUE)) {
    BiocManager::install("org.Hs.eg.db")
}
suppressMessages(library("AnnotationDbi"))
suppressMessages(library("org.Hs.eg.db"))

# Map to HUGO symbols and add as a new column 'gname' to our table
if (!any(colnames(counts) == 'gname')) {
  counts <- cbind(counts, gname=mapIds(org.Hs.eg.db,keys=rownames(counts),column="SYMBOL",keytype="ENSEMBL",multiVals="first"))
}

# Now check for duplicates in newly added gname column
any(duplicated(counts$gname)) # Yes there are duplicates!
counts
```

# 4 - Clean the data
We want to do some filtering and cleaning up the data before moving onto normalization
```{r}
# We have over 63,000 genes to account for, but genes with low counts should be removed prior to downstream analysis, because from a statistical point of view, low counts are not feasible to make reliable judgements.
# Based on edgeR recommendations, we shall keep our minumum count as 2, since we have a test sample type with only 2 replicates.

library(edgeR)
cpms = cpm(counts[,2:18])
rownames(cpms) <- counts[,1]
keep = rowSums(cpms >1) >=2
counts_filtered <- counts[keep,]

dim(counts_filtered) # returns [1] 14935    19

# Number of genes that are 'NA', that don't map to anything
no_gene_counts <- sum(is.na(counts_filtered$gname))
no_gene_counts # returns [1] 1327

# Even if a gene is labelled as 'NA' we still keep it, because it has nothing to do with the validity of the gene count. It just means that a gene symbol needs to be requested.

# Before filtering, there were lots of duplicates, but after removing the ones with low counts we look at the duplicates and we barely have any 
summarized_gene_counts <- sort(table(counts_filtered$gname),decreasing = TRUE)
summarized_gene_counts <- which(summarized_gene_counts>1)
summarized_gene_counts
# returns 
# LMF1   RAD54B TRAPPC13 
#   1        2        3

```


# 5 - Normalize the data
Let's represent our filtered data through a box plot.
```{r}
data2plot <- log2(cpm(counts_filtered[,2:18]))
boxplot(data2plot, xlab = "Samples", ylab = "log2 CPM", 
        las = 2, cex = 0.5, cex.lab = 0.5,
        cex.axis = 0.5, main = "A549 cells RNASeq Samples, before normalization")
#draw the median on each box plot
abline(h = median(apply(data2plot, 2, median)), col = "red", lwd = 0.9, lty = "dashed")

```

There are outliers in each of our 17 samples. By looking at the boxplot, there are a lot of values far above and below the median. These samples may require more investigation.  When I take a look at the sample table data, I can also see that there are a wide range of values for gene count. 

According to the journal, _An Iterative Leave-One-Out Approach to Outlier Detection in RNA-Seq Data_ by , "RNA-seq measures RNA content through digital expression profiling by counting the number of sequencing reads that map to a particular feature (e.g. exon, gene, or transcript). Given the dynamic range of RNA-seq data and practically no ceiling for quantification, extreme high counts (i.e. outliers) for a given feature are often present in one or more RNA samples within an experimental group."

Because of this, I have chosen to leave the outliers as is. 

Let's normalize the data by TTM. I am choosing TTM because, my analysis is between the different samples, and it is said to be one of the methods that perform well both with the ability to detect and control false positives. 
And since my data includes a lot of outliers in both extremes, TTM will allow me to remove the upper and lower percentages.

```{r}
library(edgeR)
filtered_counts_matrix <- as.matrix(counts_filtered[,2:18])
rownames(filtered_counts_matrix) <- counts_filtered$ensembl75_id
d = DGEList(counts=filtered_counts_matrix, group=samples$Transduced)

d = calcNormFactors(d)
normalized_counts <- cpm(d)
```

After normalization..
```{r}
norm_data <- log2(cpm(normalized_counts[,1:17]))
boxplot(norm_data, xlab = "Samples", ylab = "log2 CPM", 
        las = 2, cex = 0.5, cex.lab = 0.5,
        cex.axis = 0.5, main = "A549 cells RNASeq Samples, after normalization")
#draw the median on each box plot
abline(h = median(apply(data2plot, 2, median)), col = "red", lwd = 0.9, lty = "dashed")

```
```{r}
#counts_filtered == normalized_counts # should return FALSE

dim(counts) - dim(counts_filtered)
# we were able to filter out 48743 rows of data from 63678 rows

```

# Discussions
Q. What are the control and test conditions of the dataset?
A. A549 cells (which are found in lung tissue), were used in the experiment. These cells were either:
- not-transduced (control condition)
- or transduced with empty vector, ELF1-WT, or ELF1-R8A mutant. (test conditions)

Q. Why is the dataset of interest to you?
A. I was particularly interested in this dataset due to recent events and outbreaks of the corona virus. Hence I wanted to choose a topic related to viral infections and/or human body immune system. So I specifically chose a dataset that was connected to viral infections like influenza. 

Q. Were there expression values that were not unique for specific genes? How did you handle these?
A. There were a few genes which got mapped to multiple expression values. After removing low counts, I ended up  

Q. Were there expression values that could not be mapped to current HUGO symbols?
A. Exactly 1327 values could not be mapped to a gene symbol.

Q. How many outliers were removed?
A. Outliers were kept because I felt like I could not remove them without coming to a valid conclusion on the reason why there were a heavy amount of outliers in the upper bound. 

Q. How did you handle replicates?
A. I had 6 types of test samples, each with 3 replicates, except one that had only 2 replicates. 

Q. What is the final coverage of your dataset?
I have a dataframe with 14935 rows for 17 samples. 


# References
R: converting Ensembl row names to Symbol ID outputs missing values in 'row.names' are not allowed. (n.d.). Retrieved from https://www.biostars.org/p/239681/

(2018, October 28). Retrieved from https://www.bioconductor.org/packages/release/workflows/vignettes/RnaSeqGeneEdgeRQL/inst/doc/edgeRQL.html#filtering-to-remove-low-counts

George, N. I., Bowyer, J. F., & Nathaniel M. Crabtree, C.-W. C. (n.d.). An Iterative Leave-One-Out Approach to Outlier Detection in RNA-Seq Data. Retrieved from https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0125224




